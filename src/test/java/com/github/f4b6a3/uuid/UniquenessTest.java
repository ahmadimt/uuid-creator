package com.github.f4b6a3.uuid;

import java.util.HashSet;
import java.util.UUID;

import com.github.f4b6a3.uuid.UuidCreator;
import com.github.f4b6a3.uuid.creator.AbstractTimeBasedUuidCreator;
import com.github.f4b6a3.uuid.creator.rfc4122.TimeBasedUuidCreator;
import com.github.f4b6a3.uuid.creator.rfc4122.TimeOrderedUuidCreator;
import com.github.f4b6a3.uuid.exception.UuidCreatorException;
import com.github.f4b6a3.uuid.strategy.timestamp.StoppedTimestampStrategy;
import com.github.f4b6a3.uuid.util.UuidUtil;

/**
 * This test starts many threads that keep requesting thousands of time-based
 * UUIDs to a single generator.
 * 
 * This is is not included in the {@link TestSuite} because it takes a long time
 * to finish.
 * 
 * The theoretical maximum amount of UUIDs that can be generated at the same
 * millisecond by a single generator without duplicated UUIDs is about 163
 * million UUIDs. It's calculated by the product of the clock sequence range and
 * the count of 100 nanosecond intervals per millisecond, that is:
 * 
 * 16,384 * 10,000 = 163,840,000.
 * 
 * My personal PC don't have enough memory and processor to test the generation
 * of 163 million UUIDs. So the amount of UUIDs generated by this test is not
 * too high.
 *
 * Each UUID is reduced to a `long` value to use less memory. The timestamp high
 * bits and the node identifier bits are ignored since they don't change.
 * 
 * The timestamp strategy used is {@link StoppedTimestampStrategy} which always
 * returns the same timestamp.
 * 
 * An exception is thrown if a UUID value is generated more than once.
 * 
 */
public class UniquenessTest {

	private int threadCount; // Number of threads to run
	private int requestCount; // Number of requests for thread

	// private long[][] cacheLong; // Store values generated per thread
	private HashSet<Long> hashSet;

	private boolean verbose; // Show progress
	private boolean exception; // Throw exception

	// Abstract time-based UUID creator
	private AbstractTimeBasedUuidCreator creator;

	/**
	 * Initialize the test.
	 * 
	 * This test is not included in the {@link TestSuite} because it takes a long
	 * time to finish.
	 * 
	 * @param threadCount
	 * @param requestCount
	 * @param creator
	 * @param verbose
	 */
	public UniquenessTest(AbstractTimeBasedUuidCreator creator, int threadCount, int requestCount, boolean verbose,
			boolean exception) {
		this.threadCount = threadCount;
		this.requestCount = requestCount;
		this.creator = creator;
		this.verbose = verbose;
		this.exception = exception;
		this.initCache();
	}

	private void initCache() {
		this.hashSet = new HashSet<>();
	}

	/**
	 * Initialize and start the threads.
	 */
	public void start() {

		Thread[] threads = new Thread[this.threadCount];

		// Instantiate and start many threads
		for (int i = 0; i < this.threadCount; i++) {
			threads[i] = new Thread(new UniquenessTestThread(i, verbose, exception));
			threads[i].start();
		}

		// Wait all the threads to finish
		for (Thread thread : threads) {
			try {
				thread.join();
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			}
		}
	}

	public class UniquenessTestThread implements Runnable {

		private int id;
		private boolean verbose;
		private boolean exception;

		public UniquenessTestThread(int id, boolean verbose, boolean exception) {
			this.id = id;
			this.verbose = verbose;
			this.exception = exception;
		}

		/**
		 * Run the test.
		 */
		@Override
		public void run() {

			long msb = 0;
			long lsb = 0;
			long value = 0;
			int progress = 0;
			int max = requestCount;

			for (int i = 0; i < max; i++) {

				// Request a UUID
				UUID uuid = null;
				try {
					uuid = creator.create();
				} catch (UuidCreatorException e) {
					// Ignore the overrun exception and try again
					uuid = creator.create();
				}

				msb = UuidUtil.extractTimestamp(uuid) << 16;
				lsb = UuidUtil.extractClockSequence(uuid);

				value = (msb | lsb);

				if (verbose) {
					// Calculate and show progress
					progress = (int) ((i * 1.0 / max) * 100);
					if (progress % 10 == 0) {
						System.out.println(String.format("[Thread %06d] %s %s %s%%", id, uuid, i, (int) progress));
					}
				}
				synchronized (hashSet) {
					// Insert the value in cache, if it does not exist in it.
					if (!hashSet.add((Long) value)) {
						if (this.exception) {
							new RuntimeException(
									String.format("[Thread %06d] %s %s %s%% [DUPLICATE]", id, uuid, i, (int) progress));
						} else {
							System.err.println(
									String.format("[Thread %06d] %s %s %s%% [DUPLICATE]", id, uuid, i, (int) progress));
						}
					}
				}
			}

			if (verbose) {
				// Finished
				System.out.println(String.format("[Thread %06d] Done.", id));
			}
		}
	}

	public static void execute(AbstractTimeBasedUuidCreator creator, int threadCount, int requestCount, boolean verbose,
			boolean exception) {
		UniquenessTest test = new UniquenessTest(creator, threadCount, requestCount, verbose, exception);
		test.start();
	}

	public static void main(String[] args) {

		System.out.println("-------------------------------------------");
		System.out.println("Time-Based");
		System.out.println("-------------------------------------------");

		TimeBasedUuidCreator creator = UuidCreator.getTimeBasedCreator()
				.withTimestampStrategy(new StoppedTimestampStrategy());

		boolean verbose = true;
		boolean exception = false;
		int threadCount = 16; // Number of threads to run
		int requestCount = 1_000_000; // Number of requests for thread

		execute(creator, threadCount, requestCount, verbose, exception);

		System.out.println("-------------------------------------------");
		System.out.println("Ordered-Based");
		System.out.println("-------------------------------------------");

		TimeOrderedUuidCreator creator2 = UuidCreator.getTimeOrderedCreator()
				.withTimestampStrategy(new StoppedTimestampStrategy());

		boolean verbose2 = true;
		boolean exception2 = false;
		int threadCount2 = 16; // Number of threads to run
		int requestCount2 = 1_000_000; // Number of requests for thread

		execute(creator2, threadCount2, requestCount2, verbose2, exception2);
	}
}
